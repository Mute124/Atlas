\doxysection{Open\+GL Interop}
\hypertarget{opengl_interop}{}\label{opengl_interop}\index{OpenGL Interop@{OpenGL Interop}}
VMA provides some features that help with interoperability with Open\+GL.\hypertarget{opengl_interop_opengl_interop_exporting_memory}{}\doxysubsection{\texorpdfstring{Exporting memory}{Exporting memory}}\label{opengl_interop_opengl_interop_exporting_memory}
If you want to attach {\ttfamily Vk\+Export\+Memory\+Allocate\+Info\+KHR} structure to {\ttfamily p\+Next} chain of memory allocations made by the library\+:

It is recommended to create \doxylink{custom_memory_pools}{Custom memory pools} for such allocations. Define and fill in your {\ttfamily Vk\+Export\+Memory\+Allocate\+Info\+KHR} structure and attach it to \doxylink{struct_vma_pool_create_info_a4e264310c10272ba393c0ba2111ce416}{Vma\+Pool\+Create\+Info\+::p\+Memory\+Allocate\+Next} while creating the custom pool. Please note that the structure must remain alive and unchanged for the whole lifetime of the \doxylink{struct_vma_pool}{Vma\+Pool}, not only while creating it, as no copy of the structure is made, but its original pointer is used for each allocation instead.

If you want to export all memory allocated by the library from certain memory types, also dedicated allocations or other allocations made from default pools, an alternative solution is to fill in Vma\+Allocator\+Create\+Info\+::p\+Type\+External\+Memory\+Handle\+Types. It should point to an array with {\ttfamily Vk\+External\+Memory\+Handle\+Type\+Flags\+KHR} to be automatically passed by the library through {\ttfamily Vk\+Export\+Memory\+Allocate\+Info\+KHR} on each allocation made from a specific memory type. Please note that new versions of the library also support dedicated allocations created in custom pools.

You should not mix these two methods in a way that allows to apply both to the same memory type. Otherwise, {\ttfamily Vk\+Export\+Memory\+Allocate\+Info\+KHR} structure would be attached twice to the {\ttfamily p\+Next} chain of {\ttfamily \doxylink{struct_vk_memory_allocate_info}{Vk\+Memory\+Allocate\+Info}}.\hypertarget{opengl_interop_opengl_interop_custom_alignment}{}\doxysubsection{\texorpdfstring{Custom alignment}{Custom alignment}}\label{opengl_interop_opengl_interop_custom_alignment}
Buffers or images exported to a different API like Open\+GL may require a different alignment, higher than the one used by the library automatically, queried from functions like {\ttfamily vk\+Get\+Buffer\+Memory\+Requirements}. To impose such alignment\+:

It is recommended to create \doxylink{custom_memory_pools}{Custom memory pools} for such allocations. Set \doxylink{struct_vma_pool_create_info_ade3eca546f0c6ab4e8fbf20eb6d854cb}{Vma\+Pool\+Create\+Info\+::min\+Allocation\+Alignment} member to the minimum alignment required for each allocation to be made out of this pool. The alignment actually used will be the maximum of this member and the alignment returned for the specific buffer or image from a function like {\ttfamily vk\+Get\+Buffer\+Memory\+Requirements}, which is called by VMA automatically.

If you want to create a buffer with a specific minimum alignment out of default pools, use special function \doxylink{group__group__alloc_ga0a4d6890fe94cf4d234ca1d78af91229}{vma\+Create\+Buffer\+With\+Alignment()}, which takes additional parameter {\ttfamily min\+Alignment}.

Note the problem of alignment affects only resources placed inside bigger {\ttfamily Vk\+Device\+Memory} blocks and not dedicated allocations, as these, by definition, always have alignment = 0 because the resource is bound to the beginning of its dedicated block. Contrary to Direct3D 12, Vulkan doesn\textquotesingle{}t have a concept of alignment of the entire memory block passed on its allocation. 